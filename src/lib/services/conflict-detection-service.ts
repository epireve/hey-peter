/**\n * HeyPeter Academy - Conflict Detection Service\n * \n * Service for detecting and resolving scheduling conflicts in 1v1 bookings\n * and class scheduling.\n */\n\nimport { supabase } from '@/lib/supabase';\nimport { CRUDService } from './crud-service';\nimport type {\n  SchedulingConflict,\n  ConflictResolution,\n  TimeSlot,\n  OneOnOneBookingDuration,\n  SchedulingError,\n} from '@/types/scheduling';\nimport type { Tables } from '@/types/database';\n\ninterface BookingConflictRequest {\n  studentId: string;\n  teacherId: string;\n  timeSlot: TimeSlot;\n  duration: OneOnOneBookingDuration;\n}\n\ninterface ClassScheduleConflictRequest {\n  studentIds: string[];\n  teacherId: string;\n  timeSlot: TimeSlot;\n  courseId: string;\n}\n\n/**\n * Conflict Detection Service Class\n */\nexport class ConflictDetectionService {\n  private static instance: ConflictDetectionService;\n  \n  // CRUD services\n  private studentsService: CRUDService<Tables<'students'>>;\n  private teachersService: CRUDService<Tables<'teachers'>>;\n  private bookingsService: CRUDService<Tables<'bookings'>>;\n  private classesService: CRUDService<Tables<'classes'>>;\n\n  private constructor() {\n    this.initializeServices();\n  }\n\n  /**\n   * Singleton pattern implementation\n   */\n  public static getInstance(): ConflictDetectionService {\n    if (!ConflictDetectionService.instance) {\n      ConflictDetectionService.instance = new ConflictDetectionService();\n    }\n    return ConflictDetectionService.instance;\n  }\n\n  /**\n   * Initialize CRUD services\n   */\n  private initializeServices(): void {\n    this.studentsService = new CRUDService({\n      table: 'students',\n      select: '*',\n      cache: { enabled: true, ttl: 300000 },\n    });\n\n    this.teachersService = new CRUDService({\n      table: 'teachers',\n      select: '*',\n      cache: { enabled: true, ttl: 300000 },\n    });\n\n    this.bookingsService = new CRUDService({\n      table: 'bookings',\n      select: '*',\n      cache: { enabled: true, ttl: 30000 },\n    });\n\n    this.classesService = new CRUDService({\n      table: 'classes',\n      select: '*',\n      cache: { enabled: true, ttl: 60000 },\n    });\n  }\n\n  /**\n   * Detect conflicts for 1v1 booking\n   */\n  public async detectBookingConflicts(\n    request: BookingConflictRequest\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    try {\n      // Check student availability conflicts\n      const studentConflicts = await this.checkStudentAvailability(\n        request.studentId,\n        request.timeSlot,\n        request.duration\n      );\n      conflicts.push(...studentConflicts);\n\n      // Check teacher availability conflicts\n      const teacherConflicts = await this.checkTeacherAvailability(\n        request.teacherId,\n        request.timeSlot,\n        request.duration\n      );\n      conflicts.push(...teacherConflicts);\n\n      // Check business rules conflicts\n      const businessRuleConflicts = await this.checkBusinessRules(\n        request.studentId,\n        request.teacherId,\n        request.timeSlot\n      );\n      conflicts.push(...businessRuleConflicts);\n\n      // Check resource conflicts (meeting rooms, etc.)\n      const resourceConflicts = await this.checkResourceAvailability(\n        request.timeSlot\n      );\n      conflicts.push(...resourceConflicts);\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error detecting booking conflicts:', error);\n      return [{\n        id: `error-${Date.now()}`,\n        type: 'resource_conflict',\n        severity: 'critical',\n        entityIds: [request.studentId, request.teacherId],\n        description: 'Error occurred while checking for conflicts',\n        resolutions: [],\n        detectedAt: new Date().toISOString(),\n      }];\n    }\n  }\n\n  /**\n   * Detect conflicts for class scheduling\n   */\n  public async detectClassConflicts(\n    request: ClassScheduleConflictRequest\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    try {\n      // Check each student's availability\n      for (const studentId of request.studentIds) {\n        const studentConflicts = await this.checkStudentAvailability(\n          studentId,\n          request.timeSlot,\n          request.timeSlot.duration\n        );\n        conflicts.push(...studentConflicts);\n      }\n\n      // Check teacher availability\n      const teacherConflicts = await this.checkTeacherAvailability(\n        request.teacherId,\n        request.timeSlot,\n        request.timeSlot.duration\n      );\n      conflicts.push(...teacherConflicts);\n\n      // Check class capacity constraints\n      const capacityConflicts = await this.checkClassCapacity(\n        request.studentIds.length,\n        request.timeSlot\n      );\n      conflicts.push(...capacityConflicts);\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error detecting class conflicts:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check student availability for conflicts\n   */\n  private async checkStudentAvailability(\n    studentId: string,\n    timeSlot: TimeSlot,\n    duration: number\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    try {\n      // Check existing bookings\n      const { data: existingBookings } = await supabase\n        .from('bookings')\n        .select('*')\n        .eq('student_id', studentId)\n        .eq('status', 'confirmed')\n        .gte('scheduled_date', timeSlot.startTime)\n        .lte('scheduled_date', timeSlot.endTime);\n\n      if (existingBookings && existingBookings.length > 0) {\n        for (const booking of existingBookings) {\n          if (this.timesOverlap(\n            timeSlot.startTime,\n            timeSlot.endTime,\n            booking.start_time,\n            booking.end_time\n          )) {\n            conflicts.push({\n              id: `student-conflict-${studentId}-${Date.now()}`,\n              type: 'student_unavailable',\n              severity: 'high',\n              entityIds: [studentId, booking.id],\n              description: `Student has an existing booking at this time`,\n              resolutions: await this.generateStudentConflictResolutions(studentId, timeSlot),\n              detectedAt: new Date().toISOString(),\n            });\n          }\n        }\n      }\n\n      // Check student preferences and blocked times\n      const studentPreferenceConflicts = await this.checkStudentPreferences(\n        studentId,\n        timeSlot\n      );\n      conflicts.push(...studentPreferenceConflicts);\n\n      // Check daily limits (max classes per day)\n      const dailyLimitConflicts = await this.checkStudentDailyLimits(\n        studentId,\n        timeSlot\n      );\n      conflicts.push(...dailyLimitConflicts);\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error checking student availability:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check teacher availability for conflicts\n   */\n  private async checkTeacherAvailability(\n    teacherId: string,\n    timeSlot: TimeSlot,\n    duration: number\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    try {\n      // Check existing bookings and classes\n      const { data: existingBookings } = await supabase\n        .from('bookings')\n        .select('*')\n        .eq('teacher_id', teacherId)\n        .eq('status', 'confirmed')\n        .gte('scheduled_date', timeSlot.startTime)\n        .lte('scheduled_date', timeSlot.endTime);\n\n      if (existingBookings && existingBookings.length > 0) {\n        for (const booking of existingBookings) {\n          if (this.timesOverlap(\n            timeSlot.startTime,\n            timeSlot.endTime,\n            booking.start_time,\n            booking.end_time\n          )) {\n            conflicts.push({\n              id: `teacher-conflict-${teacherId}-${Date.now()}`,\n              type: 'teacher_unavailable',\n              severity: 'critical',\n              entityIds: [teacherId, booking.id],\n              description: `Teacher has an existing booking at this time`,\n              resolutions: await this.generateTeacherConflictResolutions(teacherId, timeSlot),\n              detectedAt: new Date().toISOString(),\n            });\n          }\n        }\n      }\n\n      // Check teacher working hours\n      const workingHoursConflicts = await this.checkTeacherWorkingHours(\n        teacherId,\n        timeSlot\n      );\n      conflicts.push(...workingHoursConflicts);\n\n      // Check teacher break time requirements\n      const breakTimeConflicts = await this.checkTeacherBreakTimes(\n        teacherId,\n        timeSlot\n      );\n      conflicts.push(...breakTimeConflicts);\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error checking teacher availability:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check business rules for conflicts\n   */\n  private async checkBusinessRules(\n    studentId: string,\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    // Check minimum advance booking time (24 hours)\n    const bookingTime = new Date();\n    const sessionTime = new Date(timeSlot.startTime);\n    const hoursUntilSession = (sessionTime.getTime() - bookingTime.getTime()) / (1000 * 60 * 60);\n\n    if (hoursUntilSession < 24) {\n      conflicts.push({\n        id: `advance-booking-${Date.now()}`,\n        type: 'time_overlap',\n        severity: 'medium',\n        entityIds: [studentId, teacherId],\n        description: 'Booking must be made at least 24 hours in advance',\n        resolutions: [{\n          id: `reschedule-${Date.now()}`,\n          type: 'reschedule',\n          description: 'Choose a time slot at least 24 hours from now',\n          impact: {\n            affectedStudents: 1,\n            affectedTeachers: 1,\n            scheduleDisruption: 1,\n            resourceUtilization: 0,\n            studentSatisfaction: -0.1,\n          },\n          feasibilityScore: 0.9,\n          estimatedImplementationTime: 5,\n          requiredApprovals: [],\n          steps: [{\n            order: 1,\n            description: 'Select a new time slot',\n            type: 'schedule_change',\n            parameters: { minAdvanceHours: 24 },\n            estimatedDuration: 5,\n            dependencies: [],\n          }],\n        }],\n        detectedAt: new Date().toISOString(),\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check resource availability\n   */\n  private async checkResourceAvailability(\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    // For online sessions, check technical resources\n    if (timeSlot.location === 'Online') {\n      // Check meeting room capacity (if applicable)\n      // Check technical infrastructure\n      // This would integrate with meeting platform APIs\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check student preferences for soft conflicts\n   */\n  private async checkStudentPreferences(\n    studentId: string,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    try {\n      // Get student preferred times\n      const { data: preferences } = await supabase\n        .from('student_preferred_times')\n        .select('*')\n        .eq('student_id', studentId);\n\n      if (preferences && preferences.length > 0) {\n        const timeSlotDay = new Date(timeSlot.startTime).getDay();\n        const timeSlotHour = new Date(timeSlot.startTime).getHours();\n        \n        const hasPreferredTime = preferences.some(pref => \n          pref.day_of_week === timeSlotDay &&\n          this.isTimeInRange(timeSlotHour, pref.start_time, pref.end_time)\n        );\n\n        if (!hasPreferredTime) {\n          conflicts.push({\n            id: `preference-${studentId}-${Date.now()}`,\n            type: 'student_unavailable',\n            severity: 'low',\n            entityIds: [studentId],\n            description: 'Time slot is outside student\\'s preferred learning times',\n            resolutions: await this.generatePreferenceConflictResolutions(studentId, timeSlot),\n            detectedAt: new Date().toISOString(),\n          });\n        }\n      }\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error checking student preferences:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check student daily limits\n   */\n  private async checkStudentDailyLimits(\n    studentId: string,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n    const maxDailyClasses = 2; // Business rule: max 2 classes per day\n\n    try {\n      const sessionDate = new Date(timeSlot.startTime).toISOString().split('T')[0];\n      \n      const { data: dailyBookings } = await supabase\n        .from('bookings')\n        .select('*')\n        .eq('student_id', studentId)\n        .eq('status', 'confirmed')\n        .gte('scheduled_date', sessionDate)\n        .lt('scheduled_date', new Date(new Date(sessionDate).getTime() + 24 * 60 * 60 * 1000).toISOString());\n\n      if (dailyBookings && dailyBookings.length >= maxDailyClasses) {\n        conflicts.push({\n          id: `daily-limit-${studentId}-${Date.now()}`,\n          type: 'student_unavailable',\n          severity: 'medium',\n          entityIds: [studentId],\n          description: `Student has reached the maximum of ${maxDailyClasses} classes per day`,\n          resolutions: await this.generateDailyLimitResolutions(studentId, timeSlot),\n          detectedAt: new Date().toISOString(),\n        });\n      }\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error checking student daily limits:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check teacher working hours\n   */\n  private async checkTeacherWorkingHours(\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n\n    // Default working hours: 9 AM to 6 PM\n    const workingHoursStart = 9;\n    const workingHoursEnd = 18;\n    \n    const sessionHour = new Date(timeSlot.startTime).getHours();\n    \n    if (sessionHour < workingHoursStart || sessionHour >= workingHoursEnd) {\n      conflicts.push({\n        id: `working-hours-${teacherId}-${Date.now()}`,\n        type: 'teacher_unavailable',\n        severity: 'high',\n        entityIds: [teacherId],\n        description: 'Session time is outside teacher\\'s working hours',\n        resolutions: await this.generateWorkingHoursResolutions(teacherId, timeSlot),\n        detectedAt: new Date().toISOString(),\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check teacher break time requirements\n   */\n  private async checkTeacherBreakTimes(\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n    const minBreakMinutes = 15; // Minimum 15 minutes between sessions\n\n    try {\n      // Get adjacent bookings\n      const sessionStart = new Date(timeSlot.startTime);\n      const sessionEnd = new Date(timeSlot.endTime);\n      \n      const beforeSession = new Date(sessionStart.getTime() - minBreakMinutes * 60 * 1000);\n      const afterSession = new Date(sessionEnd.getTime() + minBreakMinutes * 60 * 1000);\n\n      const { data: adjacentBookings } = await supabase\n        .from('bookings')\n        .select('*')\n        .eq('teacher_id', teacherId)\n        .eq('status', 'confirmed')\n        .or(`and(start_time.gte.${beforeSession.toISOString()},start_time.lt.${sessionStart.toISOString()}),and(end_time.gt.${sessionEnd.toISOString()},end_time.lte.${afterSession.toISOString()})`);\n\n      if (adjacentBookings && adjacentBookings.length > 0) {\n        conflicts.push({\n          id: `break-time-${teacherId}-${Date.now()}`,\n          type: 'teacher_unavailable',\n          severity: 'medium',\n          entityIds: [teacherId],\n          description: `Teacher needs a ${minBreakMinutes}-minute break between sessions`,\n          resolutions: await this.generateBreakTimeResolutions(teacherId, timeSlot),\n          detectedAt: new Date().toISOString(),\n        });\n      }\n\n      return conflicts;\n    } catch (error) {\n      console.error('Error checking teacher break times:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Check class capacity constraints\n   */\n  private async checkClassCapacity(\n    studentCount: number,\n    timeSlot: TimeSlot\n  ): Promise<SchedulingConflict[]> {\n    const conflicts: SchedulingConflict[] = [];\n    \n    if (studentCount > timeSlot.capacity.maxStudents) {\n      conflicts.push({\n        id: `capacity-${Date.now()}`,\n        type: 'capacity_exceeded',\n        severity: 'critical',\n        entityIds: [],\n        description: `Number of students (${studentCount}) exceeds maximum capacity (${timeSlot.capacity.maxStudents})`,\n        resolutions: await this.generateCapacityResolutions(studentCount, timeSlot),\n        detectedAt: new Date().toISOString(),\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Helper method to check if times overlap\n   */\n  private timesOverlap(\n    start1: string,\n    end1: string,\n    start2: string,\n    end2: string\n  ): boolean {\n    const s1 = new Date(start1).getTime();\n    const e1 = new Date(end1).getTime();\n    const s2 = new Date(start2).getTime();\n    const e2 = new Date(end2).getTime();\n\n    return s1 < e2 && s2 < e1;\n  }\n\n  /**\n   * Helper method to check if time is in range\n   */\n  private isTimeInRange(hour: number, startTime: string, endTime: string): boolean {\n    const start = parseInt(startTime.split(':')[0]);\n    const end = parseInt(endTime.split(':')[0]);\n    return hour >= start && hour < end;\n  }\n\n  /**\n   * Generate resolution strategies for different conflict types\n   */\n  private async generateStudentConflictResolutions(\n    studentId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `reschedule-student-${Date.now()}`,\n        type: 'reschedule',\n        description: 'Reschedule to a different time when student is available',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 1,\n          scheduleDisruption: 2,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.2,\n        },\n        feasibilityScore: 0.8,\n        estimatedImplementationTime: 10,\n        requiredApprovals: ['student'],\n        steps: [{\n          order: 1,\n          description: 'Find alternative time slot',\n          type: 'schedule_change',\n          parameters: { studentId, originalTime: timeSlot.startTime },\n          estimatedDuration: 10,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generateTeacherConflictResolutions(\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `reassign-teacher-${Date.now()}`,\n        type: 'reassign_teacher',\n        description: 'Assign a different teacher for this time slot',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 2,\n          scheduleDisruption: 3,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.3,\n        },\n        feasibilityScore: 0.6,\n        estimatedImplementationTime: 15,\n        requiredApprovals: ['admin'],\n        steps: [{\n          order: 1,\n          description: 'Find alternative teacher',\n          type: 'resource_allocation',\n          parameters: { originalTeacherId: teacherId, timeSlot },\n          estimatedDuration: 15,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generatePreferenceConflictResolutions(\n    studentId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `preference-override-${Date.now()}`,\n        type: 'manual_intervention',\n        description: 'Proceed with booking despite preference mismatch',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 0,\n          scheduleDisruption: 1,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.1,\n        },\n        feasibilityScore: 0.9,\n        estimatedImplementationTime: 1,\n        requiredApprovals: ['student'],\n        steps: [{\n          order: 1,\n          description: 'Confirm booking despite preference',\n          type: 'approval_required',\n          parameters: { reason: 'outside_preferred_times' },\n          estimatedDuration: 1,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generateDailyLimitResolutions(\n    studentId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `reschedule-different-day-${Date.now()}`,\n        type: 'reschedule',\n        description: 'Reschedule to a different day',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 1,\n          scheduleDisruption: 4,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.3,\n        },\n        feasibilityScore: 0.7,\n        estimatedImplementationTime: 10,\n        requiredApprovals: ['student'],\n        steps: [{\n          order: 1,\n          description: 'Find available time on different day',\n          type: 'schedule_change',\n          parameters: { excludeDate: timeSlot.startTime.split('T')[0] },\n          estimatedDuration: 10,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generateWorkingHoursResolutions(\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `working-hours-reschedule-${Date.now()}`,\n        type: 'reschedule',\n        description: 'Reschedule to teacher\\'s working hours',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 1,\n          scheduleDisruption: 2,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.2,\n        },\n        feasibilityScore: 0.9,\n        estimatedImplementationTime: 5,\n        requiredApprovals: [],\n        steps: [{\n          order: 1,\n          description: 'Select time within working hours',\n          type: 'schedule_change',\n          parameters: { workingHours: '09:00-18:00' },\n          estimatedDuration: 5,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generateBreakTimeResolutions(\n    teacherId: string,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `break-time-adjustment-${Date.now()}`,\n        type: 'reschedule',\n        description: 'Adjust time to allow for teacher break',\n        impact: {\n          affectedStudents: 1,\n          affectedTeachers: 1,\n          scheduleDisruption: 1,\n          resourceUtilization: 0,\n          studentSatisfaction: -0.1,\n        },\n        feasibilityScore: 0.8,\n        estimatedImplementationTime: 5,\n        requiredApprovals: [],\n        steps: [{\n          order: 1,\n          description: 'Adjust time by 15 minutes',\n          type: 'schedule_change',\n          parameters: { minBreak: 15 },\n          estimatedDuration: 5,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n\n  private async generateCapacityResolutions(\n    studentCount: number,\n    timeSlot: TimeSlot\n  ): Promise<ConflictResolution[]> {\n    return [\n      {\n        id: `split-class-${Date.now()}`,\n        type: 'split_class',\n        description: 'Split into multiple smaller classes',\n        impact: {\n          affectedStudents: studentCount,\n          affectedTeachers: 2,\n          scheduleDisruption: 5,\n          resourceUtilization: -0.2,\n          studentSatisfaction: -0.1,\n        },\n        feasibilityScore: 0.6,\n        estimatedImplementationTime: 20,\n        requiredApprovals: ['admin'],\n        steps: [{\n          order: 1,\n          description: 'Create additional class sessions',\n          type: 'resource_allocation',\n          parameters: { originalCapacity: timeSlot.capacity.maxStudents, totalStudents: studentCount },\n          estimatedDuration: 20,\n          dependencies: [],\n        }],\n      }\n    ];\n  }\n}\n\n// Export singleton instance\nexport const conflictDetectionService = ConflictDetectionService.getInstance();"