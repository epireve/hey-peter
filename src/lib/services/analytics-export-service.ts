import { format } from 'date-fns';
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

export type ExportFormat = 'csv' | 'excel' | 'json' | 'pdf';

export interface ExportOptions {
  format: ExportFormat;
  fileName?: string;
  includeHeaders?: boolean;
  dateFormat?: string;
}

export interface ChartExportData {
  title: string;
  type: 'line' | 'bar' | 'pie' | 'area';
  data: any[];
  xAxis?: string;
  yAxis?: string;
}

class AnalyticsExportService {
  async exportData(
    data: any[],
    options: ExportOptions,
    metadata?: {
      title?: string;
      description?: string;
      generatedBy?: string;
      dateRange?: { start: Date; end: Date };
    }
  ): Promise<void> {
    try {
      const fileName = options.fileName || `analytics-export-${format(new Date(), 'yyyy-MM-dd-HHmmss')}`;

      switch (options.format) {
        case 'csv':
          await this.exportToCSV(data, fileName, options);
          break;
        case 'excel':
          await this.exportToExcel(data, fileName, options, metadata);
          break;
        case 'json':
          await this.exportToJSON(data, fileName, metadata);
          break;
        case 'pdf':
          await this.exportToPDF(data, fileName, metadata);
          break;
        default:
          throw new Error(`Unsupported export format: ${options.format}`);
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }

  async exportChart(
    chartData: ChartExportData,
    options: ExportOptions
  ): Promise<void> {
    try {
      const fileName = options.fileName || `chart-export-${format(new Date(), 'yyyy-MM-dd-HHmmss')}`;

      if (options.format === 'excel') {
        await this.exportChartToExcel(chartData, fileName);
      } else if (options.format === 'csv') {
        await this.exportToCSV(chartData.data, fileName, options);
      } else {
        // For other formats, export the raw data
        await this.exportData(chartData.data, options);
      }
    } catch (error) {
      console.error('Chart export failed:', error);
      throw error;
    }
  }

  async exportDashboard(
    dashboardData: {
      summary: any;
      charts: ChartExportData[];
      tables: { name: string; data: any[] }[];
    },
    options: ExportOptions
  ): Promise<void> {
    try {
      const fileName = options.fileName || `dashboard-export-${format(new Date(), 'yyyy-MM-dd-HHmmss')}`;

      if (options.format === 'excel') {
        await this.exportDashboardToExcel(dashboardData, fileName);
      } else if (options.format === 'pdf') {
        await this.exportDashboardToPDF(dashboardData, fileName);
      } else {
        // For other formats, combine all data
        const combinedData = {
          summary: dashboardData.summary,
          charts: dashboardData.charts.map(chart => ({
            title: chart.title,
            data: chart.data
          })),
          tables: dashboardData.tables
        };
        await this.exportToJSON(combinedData, fileName);
      }
    } catch (error) {
      console.error('Dashboard export failed:', error);
      throw error;
    }
  }

  private async exportToCSV(
    data: any[],
    fileName: string,
    options: ExportOptions
  ): Promise<void> {
    if (!data || data.length === 0) {
      throw new Error('No data to export');
    }

    const headers = Object.keys(data[0]);
    const csvContent = [
      options.includeHeaders !== false ? headers.join(',') : '',
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          // Handle dates
          if (value instanceof Date) {
            return format(value, options.dateFormat || 'yyyy-MM-dd HH:mm:ss');
          }
          // Handle strings with commas
          if (typeof value === 'string' && value.includes(',')) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value ?? '';
        }).join(',')
      )
    ].filter(line => line).join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    saveAs(blob, `${fileName}.csv`);
  }

  private async exportToExcel(
    data: any[],
    fileName: string,
    options: ExportOptions,
    metadata?: any
  ): Promise<void> {
    const workbook = XLSX.utils.book_new();

    // Add metadata sheet if provided
    if (metadata) {
      const metadataSheet = XLSX.utils.json_to_sheet([
        { Property: 'Title', Value: metadata.title || 'Analytics Export' },
        { Property: 'Description', Value: metadata.description || '' },
        { Property: 'Generated By', Value: metadata.generatedBy || 'Hey Peter Analytics' },
        { Property: 'Generated On', Value: format(new Date(), 'yyyy-MM-dd HH:mm:ss') },
        { Property: 'Date Range', Value: metadata.dateRange 
          ? `${format(metadata.dateRange.start, 'yyyy-MM-dd')} to ${format(metadata.dateRange.end, 'yyyy-MM-dd')}`
          : 'All time' 
        }
      ]);
      XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Metadata');
    }

    // Add data sheet
    const dataSheet = XLSX.utils.json_to_sheet(data);
    
    // Apply formatting
    const range = XLSX.utils.decode_range(dataSheet['!ref'] || 'A1');
    
    // Format headers
    for (let col = range.s.c; col <= range.e.c; col++) {
      const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
      if (dataSheet[headerCell]) {
        dataSheet[headerCell].s = {
          font: { bold: true },
          fill: { fgColor: { rgb: 'E0E0E0' } },
          alignment: { horizontal: 'center' }
        };
      }
    }

    // Format date columns
    for (let row = range.s.r + 1; row <= range.e.r; row++) {
      for (let col = range.s.c; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
        const cell = dataSheet[cellAddress];
        
        if (cell && cell.v instanceof Date) {
          cell.t = 'd';
          cell.z = options.dateFormat || 'yyyy-mm-dd hh:mm:ss';
        }
      }
    }

    XLSX.utils.book_append_sheet(workbook, dataSheet, 'Data');

    // Write file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, `${fileName}.xlsx`);
  }

  private async exportToJSON(
    data: any,
    fileName: string,
    metadata?: any
  ): Promise<void> {
    const exportData = {
      metadata: {
        exportedAt: new Date().toISOString(),
        version: '1.0',
        ...metadata
      },
      data
    };

    const jsonString = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    saveAs(blob, `${fileName}.json`);
  }

  private async exportToPDF(
    data: any[],
    fileName: string,
    metadata?: any
  ): Promise<void> {
    // For PDF export, we'll create an HTML representation and trigger print
    const html = this.generateHTMLReport(data, metadata);
    
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(html);
      printWindow.document.close();
      printWindow.focus();
      
      setTimeout(() => {
        printWindow.print();
        printWindow.close();
      }, 250);
    }
  }

  private async exportChartToExcel(
    chartData: ChartExportData,
    fileName: string
  ): Promise<void> {
    const workbook = XLSX.utils.book_new();

    // Add chart metadata
    const metadataSheet = XLSX.utils.json_to_sheet([
      { Property: 'Chart Title', Value: chartData.title },
      { Property: 'Chart Type', Value: chartData.type },
      { Property: 'X-Axis', Value: chartData.xAxis || 'Category' },
      { Property: 'Y-Axis', Value: chartData.yAxis || 'Value' },
      { Property: 'Data Points', Value: chartData.data.length }
    ]);
    XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Chart Info');

    // Add chart data
    const dataSheet = XLSX.utils.json_to_sheet(chartData.data);
    XLSX.utils.book_append_sheet(workbook, dataSheet, 'Chart Data');

    // Write file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, `${fileName}.xlsx`);
  }

  private async exportDashboardToExcel(
    dashboardData: any,
    fileName: string
  ): Promise<void> {
    const workbook = XLSX.utils.book_new();

    // Add summary sheet
    const summarySheet = XLSX.utils.json_to_sheet([dashboardData.summary]);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

    // Add charts
    dashboardData.charts.forEach((chart: ChartExportData, index: number) => {
      const chartSheet = XLSX.utils.json_to_sheet(chart.data);
      XLSX.utils.book_append_sheet(workbook, chartSheet, `Chart ${index + 1} - ${chart.title.slice(0, 20)}`);
    });

    // Add tables
    dashboardData.tables.forEach((table: any) => {
      const tableSheet = XLSX.utils.json_to_sheet(table.data);
      XLSX.utils.book_append_sheet(workbook, tableSheet, table.name.slice(0, 30));
    });

    // Write file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, `${fileName}.xlsx`);
  }

  private async exportDashboardToPDF(
    dashboardData: any,
    fileName: string
  ): Promise<void> {
    const html = this.generateDashboardHTML(dashboardData);
    
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(html);
      printWindow.document.close();
      printWindow.focus();
      
      setTimeout(() => {
        printWindow.print();
        printWindow.close();
      }, 250);
    }
  }

  private generateHTMLReport(data: any[], metadata?: any): string {
    const styles = `
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #333; }
        .metadata { background: #f5f5f5; padding: 10px; margin-bottom: 20px; }
        table { border-collapse: collapse; width: 100%; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4a90e2; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        @media print {
          body { margin: 0; }
          .no-print { display: none; }
        }
      </style>
    `;

    const metadataHTML = metadata ? `
      <div class="metadata">
        <h2>Report Information</h2>
        <p><strong>Title:</strong> ${metadata.title || 'Analytics Report'}</p>
        <p><strong>Generated:</strong> ${format(new Date(), 'yyyy-MM-dd HH:mm:ss')}</p>
        ${metadata.dateRange ? `<p><strong>Date Range:</strong> ${format(metadata.dateRange.start, 'yyyy-MM-dd')} to ${format(metadata.dateRange.end, 'yyyy-MM-dd')}</p>` : ''}
      </div>
    ` : '';

    const tableHTML = data.length > 0 ? `
      <table>
        <thead>
          <tr>
            ${Object.keys(data[0]).map(key => `<th>${key}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${data.map(row => `
            <tr>
              ${Object.values(row).map(value => `<td>${value}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    ` : '<p>No data available</p>';

    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>${metadata?.title || 'Analytics Report'}</title>
          ${styles}
        </head>
        <body>
          <h1>${metadata?.title || 'Analytics Report'}</h1>
          ${metadataHTML}
          ${tableHTML}
        </body>
      </html>
    `;
  }

  private generateDashboardHTML(dashboardData: any): string {
    const styles = `
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2, h3 { color: #333; }
        .summary { background: #f5f5f5; padding: 15px; margin-bottom: 20px; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
        .summary-item { background: white; padding: 10px; border-radius: 5px; }
        .chart-section { margin: 20px 0; page-break-inside: avoid; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4a90e2; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        @media print {
          body { margin: 0; }
          .no-print { display: none; }
          .chart-section { page-break-inside: avoid; }
        }
      </style>
    `;

    const summaryHTML = `
      <div class="summary">
        <h2>Dashboard Summary</h2>
        <div class="summary-grid">
          ${Object.entries(dashboardData.summary).map(([key, value]) => `
            <div class="summary-item">
              <strong>${key}:</strong> ${value}
            </div>
          `).join('')}
        </div>
      </div>
    `;

    const chartsHTML = dashboardData.charts.map((chart: ChartExportData) => `
      <div class="chart-section">
        <h3>${chart.title}</h3>
        <table>
          <thead>
            <tr>
              ${Object.keys(chart.data[0] || {}).map(key => `<th>${key}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
            ${chart.data.map(row => `
              <tr>
                ${Object.values(row).map(value => `<td>${value}</td>`).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `).join('');

    const tablesHTML = dashboardData.tables.map((table: any) => `
      <div class="chart-section">
        <h3>${table.name}</h3>
        <table>
          <thead>
            <tr>
              ${Object.keys(table.data[0] || {}).map(key => `<th>${key}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
            ${table.data.map((row: any) => `
              <tr>
                ${Object.values(row).map((value: any) => `<td>${value}</td>`).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `).join('');

    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Dashboard Export</title>
          ${styles}
        </head>
        <body>
          <h1>Analytics Dashboard Export</h1>
          <p>Generated on ${format(new Date(), 'yyyy-MM-dd HH:mm:ss')}</p>
          ${summaryHTML}
          <h2>Charts</h2>
          ${chartsHTML}
          <h2>Detailed Tables</h2>
          ${tablesHTML}
        </body>
      </html>
    `;
  }

  // Utility method to prepare data for export
  prepareDataForExport(data: any[], columns?: string[]): any[] {
    if (!columns || columns.length === 0) {
      return data;
    }

    return data.map(row => {
      const exportRow: any = {};
      columns.forEach(col => {
        exportRow[col] = row[col];
      });
      return exportRow;
    });
  }

  // Method to generate filename with timestamp
  generateFileName(prefix: string, extension: string): string {
    const timestamp = format(new Date(), 'yyyy-MM-dd-HHmmss');
    return `${prefix}-${timestamp}.${extension}`;
  }
}

export const analyticsExportService = new AnalyticsExportService();